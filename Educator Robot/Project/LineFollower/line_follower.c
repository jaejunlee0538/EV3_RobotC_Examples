#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void stop_left_right_motor()
{
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

unsigned int motor_stop_duration = 0;
task task_left_right_motor_stop()
{
	clearTimer(T4);
	while(time1[T4] < motor_stop_duration)
	{
	}

	stop_left_right_motor();
}

void steering_robot(int steering, int motor_power, unsigned int duration_ms=0, TMotorBrakeModes brake=motorBrake)
{
	stopTask(task_left_right_motor_stop);

	if(getMotorBrakeMode(leftMotor)!=motorBrake)
		setMotorBrakeMode(leftMotor, motorBrake);
	if(getMotorBrakeMode(rightMotor)!=motorBrake)
		setMotorBrakeMode(rightMotor, motorBrake);

	int left_motor_power, right_motor_power;

	if(abs(motor_power) > 100)
		motor_power = sgn(motor_power)*100;
	if(abs(steering) > 100)
		steering = sgn(steering)*100;	//limitting steering within -100~100

	if(steering > 0)
	{
		left_motor_power = motor_power;
		right_motor_power = motor_power * (1 - steering*2/100.0);
	}
	else if(steering < 0)
	{
		left_motor_power = motor_power * (1 + steering*2/100.0);
		right_motor_power = motor_power;
	}
	else
	{
		left_motor_power = motor_power;
		right_motor_power = motor_power;
	}

	setMotorSpeed(leftMotor, left_motor_power);
	setMotorSpeed(rightMotor, right_motor_power);

	motor_stop_duration = duration_ms;
	if(duration_ms > 0)
	{
		startTask(task_left_right_motor_stop);
	}
}

void button_blocking(const char button)
{
	while(!getButtonPress(buttonEnter));
	while(getButtonPress(buttonEnter));
}


#define BUTTON_P_GAIN buttonLeft
#define BUTTON_I_GAIN buttonUP
#define BUTTON_D_GAIN buttonRight
#define BUTTON_DONE		buttonEnter

void tunning_P_gain(void)
{
}

void tunning_I_gain(void)
{
}

void tunning_D_gain(void)
{
}

void gain_tuning()
{
	stop_left_right_motor();

	while(true)
	{
		if(getButtonPress(BUTTON_P_GAIN))
			tunning_P_gain();
		if(getButtonPress(BUTTON_I_GAIN))
			tunning_I_gain();
		if(getButtonPress(BUTTON_D_GAIN))
			tunning_D_gain();
		if(getButtonPress(BUTTON_DONE))
		{
			break;
		}
	}
}

task main()
{

	unsigned short reflected_middle = 42;
	//unsigned short reflected_black, reflected_white;
	//getColorReflected(colorSensor);
	//wait1Msec(500);

	//playSoundFile("Black");
	//button_blocking(buttonEnter);
	//reflected_black = getColorReflected(colorSensor);

	//playSoundFile("White");
	//button_blocking(buttonEnter);
	//reflected_white = getColorReflected(colorSensor);

	//reflected_middle = (reflected_black + reflected_white) / 2;
	////displayCenteredBigTextLine(0,"%d",reflected_middle);

	playSoundFile("Ready");
	button_blocking(buttonEnter);

	int motor_power = 60;
	int steering = 0;
	int error=0;
	int last_error=0;
	int error_integration=0;

	float P_gain = 2.0;
	float D_gain = 1.0;
	float I_gain = 0.0;

	unsigned int reflected_value;

	while(true)
	{
		reflected_value = getColorReflected(colorSensor);
		error = (reflected_value - reflected_middle);
		steering = P_gain*error + D_gain*(error - last_error) + I_gain*error_integration;
		error_integration += error;
		last_error = error;

		steering_robot(steering, motor_power);
	}

}
