#pragma config(Sensor, S1,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const static float R_WHEEL = 0.056*0.5;
const static float TRACK = 0.117;


void stop_motors(void)
{
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

void point_turn(int speed)
{
	setMotorSpeed(leftMotor, speed);
	setMotorSpeed(rightMotor, -speed);
}

void reset_motor_encoder(void)
{
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
}

float calculate_point_turn_angle(int left_encoder, int right_encoder)
{
	int encoder = (abs(left_encoder) + abs(right_encoder))*0.5;

	return sgn(left_encoder)*(encoder * R_WHEEL / TRACK * 2.0);
}

unsigned char distance_data[3600];

task main()
{
	for(int i=0;i<3600;i++)
		distance_data[i] = 0;

	int data_cnt = 0;

	wait1Msec(4000);
	resetGyro(gyroSensor);

	point_turn(8);
	long deg_rotated = 0;
	float us_distance = 0;
	reset_motor_encoder();
	while(true)
	{
		//deg_rotated = calculate_point_turn_angle(getMotorEncoder(leftMotor), getMotorEncoder(rightMotor));
		deg_rotated = getGyroDegrees(gyroSensor);
		us_distance = getUSDistance(sonarSensor);
		if(deg_rotated >= 360)
			break;

		distance_data[(int)(deg_rotated*10)] = (unsigned char)us_distance;
	}
	stop_motors();

	long file = fileOpenWrite("sonar_scan.txt");
	for(int i=0;i<3600;i++)
	{
		fileWriteFloat(file, distance_data[i]);
	}
	fileClose(file);
}
