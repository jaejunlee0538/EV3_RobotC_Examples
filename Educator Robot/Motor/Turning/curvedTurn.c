#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
	//Desired Values
	float deg = 90;		//How much degrees you want the robot to turn.
	float R = 0.05;		//In which turning radius?	R is the distance from the center of slower wheel to center of rotation.
	float speed = 10;	//speed of slower wheel.

	//Contants
	float R_wheel = 0.056 * 0.5; //radius of wheel in meters
	float track = 0.117; //length from left wheel to right wheel in meters

	//calculation.
	float v_slow = speed;	//speed of slower wheel
	float v_fast = (track / R + 1.0)*v_slow;	//speed of faster wheel. v_fast adapts so as to attain the desired R and speed.
	float distance = R * abs(deg) * PI/180;		//The distance slow-wheel should travel.
	float deg_of_wheel = distance / R_wheel * 180.0/PI;	//Conversion from distance unit to angular unit.

	if(deg > 0.0)
	{
		//Left Turn : Slow(left), Fast(right)
		moveMotorTarget(leftMotor, deg_of_wheel, v_slow);
		setMotorSpeed(rightMotor, v_fast);
		waitUntilMotorStop(leftMotor);
	}
	else if(deg < 0.0)
	{
		//Right Turn : Slow(right), Fast(left)
		setMotorSpeed(leftMotor, v_fast);
		moveMotorTarget(rightMotor, deg_of_wheel, v_slow);
		waitUntilMotorStop(rightMotor);
	}
	else{
		//Don't move.
		setMotorSpeed(leftMotor, 0);
		setMotorSpeed(rightMotor, 0);
	}
}
